<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Word Imposter</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto&display=swap');

    body {
      font-family: 'Roboto', sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background: radial-gradient(circle at center, #1a1a1a, #0f0f0f);
      color: #e0e0e0;
      -webkit-user-select:none; user-select:none;
      -webkit-touch-callout:none;
    }

    .container {
      background-color: rgba(30, 30, 30, 0.9);
      padding: 25px;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(138, 43, 226, 0.3);
      backdrop-filter: blur(6px);
    }

    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 32px;
      text-align: center;
      color: #e4c1f9;
      margin-bottom: 20px;
    }

    h2 {
      color: #ffffff;
      text-align: center;
      margin-bottom: 15px;
    }

    .word-input input, .player-input input {
      width: 100%;
      padding: 12px;
      margin: 5px 0;
      background: #2b2b2b;
      border: 1px solid #444;
      color: #f0f0f0;
      border-radius: 8px;
      font-size: 16px;
    }

    .word-display {
      font-size: 28px;
      text-align: center;
      margin: 30px 0;
      padding: 25px;
      background: #222;
      border-radius: 12px;
      color: #b8faff;
      box-shadow: inset 0 0 10px #111;
    }

    .imposter-word {
      color: #ff3b3b;
      font-weight: bold;
      letter-spacing: 1px;
    }

    .player-list {
      list-style: none;
      padding: 0;
    }

    .player-list li {
      margin: 10px 0;
      padding: 12px;
      background-color: #2b2b2b;
      border-radius: 8px;
      cursor: pointer;
    }

    .player-list li.selected {
      background-color: #4444aa;
    }

    .scores { margin-top: 20px; }

    button {
      padding: 12px 20px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin: 10px 5px;
      background: linear-gradient(135deg, #6a0dad, #b026ff);
      color: white;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover { transform: scale(1.05); box-shadow: 0 0 12px #b026ff88; }

    .phase { display: none; }

    /* ===== Finger-Chooser Styles ===== */
    #chooserSurface {
      position: relative;
      width: 100%;
      height: 56vh;
      min-height: 360px;
      background: radial-gradient(800px 500px at 50% 30%, #1f1f1f, #141414);
      border: 1px solid #333;
      border-radius: 14px;
      overflow: hidden;
      touch-action: none; /* Multi-Touch Gesten unterbinden */
    }
    .touchDot {
      position: absolute;
      width: 84px; height: 84px; margin: -42px 0 0 -42px;
      border-radius: 50%;
      border: 3px solid #8ab4f8;
      background: #8ab4f81a;
      display: grid; place-items: center;
      color: #dbeafe; font-weight: 700;
      transition: transform .12s ease;
      pointer-events: none;
      box-shadow: 0 0 0 0 rgba(56,189,248,.6);
    }
    .touchDot::after{
      content:''; position:absolute; inset:-10px; border-radius:50%;
      border:2px dashed rgba(138,180,248,.35);
      animation: spin 2.6s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .pulse { animation: pulse 1s ease-in-out infinite; }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(56,189,248,.6); }
      70% { box-shadow: 0 0 0 18px rgba(56,189,248,0); }
      100% { box-shadow: 0 0 0 0 rgba(56,189,248,0); }
    }
    .winnerDot {
      border-color: #22c55e;
      background: #22c55e26;
      color: #dcfce7;
      transform: scale(1.2) !important;
    }
    .winnerDot::after { border-color: rgba(34,197,94,.45); }
    .chooserInfo {
      text-align:center;
      margin-top: 10px;
      opacity:.9;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Word Imposter Game</h1>
  <div id="game"></div>
</div>
<script>
let players = [], allWords = [], usedWords = [], currentWord = '', currentPlayer = 0;
let imposters = [], currentRound = 1, currentCycle = 1, selectedImposterIndices = [];
let gameMode = 'single';
const maxRounds = 10;

/* ==== Phasenverwaltung (Chooser ergänzt) ==== */
const phases = ["modeSelectPhase","playerSetupPhase","wordInputPhase","handoverPhase","wordDisplayPhase","chooserPhase","cyclePhase","votingPhase","scoresPhase"];
function showPhase(id) {
  phases.forEach(p => {
    let el = document.getElementById(p);
    if (el) el.style.display = (p === id ? "block" : "none");
  });
}

function selectMode(mode) {
  gameMode = mode;
  showPhase('playerSetupPhase');
}

function addPlayerField() {
  const playerInputs = document.getElementById('playerInputs');
  const newPlayer = document.createElement('div');
  newPlayer.className = 'player-input';
  newPlayer.innerHTML = '<input type="text" placeholder="Player Name" required>';
  playerInputs.appendChild(newPlayer);
}

function startGame() {
  const inputs = document.querySelectorAll('.player-input input');
  players = Array.from(inputs).map(input => ({ name: input.value.trim(), score: 0 })).filter(p => p.name);
  if (players.length < 2) return alert("Mindestens 2 Spieler!");
  currentPlayer = 0; allWords = []; usedWords = []; currentRound = 1; currentCycle = 1;
  document.getElementById('currentPlayerName').textContent = players[currentPlayer].name;
  showPhase('wordInputPhase');
}

function saveWords() {
  const inputs = document.querySelectorAll('.word-input input');
  const words = Array.from(inputs).map(i => i.value.trim());
  if (words.length !== 5 || words.some(w => !w)) return alert("Bitte 5 Wörter eingeben!");
  allWords.push(...words); currentPlayer++;
  if (currentPlayer >= players.length) startRound();
  else {
    inputs.forEach(i => i.value = '');
    document.getElementById('currentPlayerName').textContent = players[currentPlayer].name;
  }
}

function startRound() {
  const remaining = allWords.filter(w => !usedWords.includes(w));
  currentWord = remaining[Math.floor(Math.random() * remaining.length)];
  usedWords.push(currentWord);

  // Imposter Auswahl basierend auf Spielmodus
  imposters = [];
  if (gameMode === 'single') {
    imposters = [Math.floor(Math.random() * players.length)];
  } else if (gameMode === 'double') {
    let indices = [...Array(players.length).keys()];
    indices.sort(() => 0.5 - Math.random());
    imposters = indices.slice(0, 2);
  } else if (gameMode === 'chaotic') {
    players.forEach((_, i) => { if (Math.random() < 0.5) imposters.push(i); });
  }

  currentPlayer = 0; currentCycle = 1;
  document.getElementById('handoverPlayerName').textContent = players[currentPlayer].name;
  document.getElementById('cycleNumber').textContent = `1. Abstimmungsrunde`;
  showPhase('handoverPhase');
}

function showPlayerWord() {
  showPhase('wordDisplayPhase');
  updateDisplayedWord();
}

function updateDisplayedWord() {
  const display = document.getElementById('displayedWord');
  if (imposters.includes(currentPlayer)) {
    display.textContent = 'IMPOSTER';
    display.classList.add('imposter-word');
  } else {
    display.textContent = currentWord;
    display.classList.remove('imposter-word');
  }
}

function nextPlayer() {
  currentPlayer++;
  if (currentPlayer >= players.length) {
    // >>> Nach dem letzten Spieler: Finger-Chooser <<<
    startChooserPhase();
  } else {
    document.getElementById('handoverPlayerName').textContent = players[currentPlayer].name;
    showPhase('handoverPhase');
  }
}

function startNextCycle() {
  currentCycle++;
  document.getElementById('cycleNumber').textContent = `${currentCycle}. Abstimmungsrunde`;
  showPhase('cyclePhase');
}

function startVoting() {
  showPhase('votingPhase');
  selectedImposterIndices = [];
  const list = document.getElementById('playerList');
  list.innerHTML = players.map((p, i) => `<li onclick="toggleImposter(${i})" id="player-${i}">${p.name}</li>`).join('');

  // Entferne vorhandene Weiter-Buttons
  const parent = list.parentElement;
  const oldButtons = parent.querySelectorAll('button');
  oldButtons.forEach(btn => btn.remove());

  const btn = document.createElement('button');
  btn.textContent = 'Weiter';
  btn.onclick = evaluateImposterGuess;
  parent.appendChild(btn);
}

function toggleImposter(index) {
  const maxVotes = (gameMode === 'single') ? 1 : (gameMode === 'double') ? 2 : players.length;
  const el = document.getElementById(`player-${index}`);

  if (selectedImposterIndices.includes(index)) {
    selectedImposterIndices = selectedImposterIndices.filter(i => i !== index);
    el.classList.remove('selected');
  } else {
    if (selectedImposterIndices.length >= maxVotes) return;
    selectedImposterIndices.push(index);
    el.classList.add('selected');
  }
}

function evaluateImposterGuess() {
  if (selectedImposterIndices.length === 0) return alert("Bitte Spieler auswählen!");
  players.forEach((_, i) => {
    const el = document.getElementById(`player-${i}`);
    if (imposters.includes(i) && selectedImposterIndices.includes(i)) el.style.backgroundColor = 'green';
    else if (!imposters.includes(i) && selectedImposterIndices.includes(i)) el.style.backgroundColor = 'red';
  });
  setTimeout(() => {
    const allCorrect = selectedImposterIndices.length === imposters.length && selectedImposterIndices.every(i => imposters.includes(i));
    revealImposter(allCorrect);
  }, 1500);
}

function revealImposter(caught) {
  if (caught) {
    imposters.forEach(i => players[i].score += (4 - currentCycle));
  } else {
    players.forEach((p, i) => { if (!imposters.includes(i)) p.score += 3; });
  }
  const scoreDiv = document.getElementById('scoreDisplay');
  scoreDiv.innerHTML = players.map(p => `<div>${p.name}: ${p.score} Schlücke</div>`).join('');
  showPhase('scoresPhase');
}

function startNewRound() {
  if (currentRound >= maxRounds) return alert("Spiel beendet!");
  currentRound++; startRound();
}

/* ===== Finger-Chooser Logik ===== */
let chooserLocked = false;
const touches = new Map(); // pointerId -> { el }

function startChooserPhase() {
  // Reset
  chooserLocked = false;
  for (const {el} of touches.values()) { try { el.remove(); } catch(_){} }
  touches.clear();

  // Anzeige setzen
  const expected = players.length;
  document.getElementById('fingerNeeded').textContent = expected.toString();
  document.getElementById('fingerCount').textContent = '0';
  document.getElementById('chooserContinue').style.display = 'none';

  showPhase('chooserPhase');
}

function chooserPointerDown(e){
  if (chooserLocked) return;
  // Maus nur 1x erlauben (zum Testen am Desktop)
  if (e.pointerType === 'mouse' && touches.size) return;

  e.preventDefault();
  const id = e.pointerId;
  if (touches.has(id)) return;

  const dot = document.createElement('div');
  dot.className = 'touchDot';
  positionDot(dot, e.clientX, e.clientY);
  dot.textContent = String(touches.size + 1);
  document.getElementById('chooserSurface').appendChild(dot);
  touches.set(id, { el: dot });

  try { e.target.setPointerCapture(e.pointerId); } catch(_){}

  updateChooserCount();
  maybePickIfReady();
}

function chooserPointerMove(e){
  if (chooserLocked) return;
  const entry = touches.get(e.pointerId);
  if (!entry) return;
  positionDot(entry.el, e.clientX, e.clientY);
  entry.el.style.transform = 'scale(1.02)';
  requestAnimationFrame(()=> entry.el && (entry.el.style.transform = 'scale(1)'));
}

function chooserPointerUp(e){
  const entry = touches.get(e.pointerId);
  if (!entry) return;
  entry.el.remove();
  touches.delete(e.pointerId);
  relabelDots();
  updateChooserCount();
}

function positionDot(el, clientX, clientY){
  const rect = document.getElementById('chooserSurface').getBoundingClientRect();
  const x = Math.max(42, Math.min(rect.width - 42, clientX - rect.left));
  const y = Math.max(42, Math.min(rect.height - 42, clientY - rect.top));
  el.style.left = x + 'px';
  el.style.top  = y + 'px';
}

function updateChooserCount(){
  document.getElementById('fingerCount').textContent = String(touches.size);
}

function relabelDots(){
  let i=1;
  for (const {el} of touches.values()) el.textContent = String(i++);
}

function maybePickIfReady(){
  const needed = players.length;
  if (touches.size === needed && !chooserLocked) {
    // kurze Spannung
    for (const {el} of touches.values()) el.classList.add('pulse');
    chooserLocked = true;

    setTimeout(() => {
      const arr = Array.from(touches.values());
      const winner = arr[Math.floor(Math.random()*arr.length)];
      for (const {el} of touches.values()) el.classList.remove('pulse');
      winner.el.classList.add('winnerDot');

      // optional Haptik (mobil)
      if (navigator.vibrate) navigator.vibrate([60,40,60]);

      // Weiter-Button anzeigen
      document.getElementById('chooserContinue').style.display = 'inline-block';
    }, 700);
  }
}

function enterFirstVote(){
  // in die 1. Abstimmungsrunde
  document.getElementById('cycleNumber').textContent = `1. Abstimmungsrunde`;
  showPhase('cyclePhase');
}

/* ====== HTML einfügen ====== */
const gameDiv = document.getElementById('game');
gameDiv.innerHTML = `
<div id="modeSelectPhase" class="phase">
  <h2>Spielmodus wählen</h2>
  <button onclick="selectMode('single')">Immer 1 Imposter</button>
  <button onclick="selectMode('double')">Immer 2 Imposter</button>
  <button onclick="selectMode('chaotic')">Vogelwilder Modus</button>
</div>

<div id="playerSetupPhase" class="phase">
  <h2>Spieler hinzufügen</h2>
  <div id="playerInputs">
    <div class="player-input"><input type="text" placeholder="Player 1" required></div>
    <div class="player-input"><input type="text" placeholder="Player 2" required></div>
  </div>
  <button onclick="addPlayerField()">Spieler hinzufügen</button>
  <button onclick="startGame()">Spiel starten</button>
</div>

<div id="wordInputPhase" class="phase">
  <h2>Wort-Eingabe</h2>
  <div id="currentPlayerDisplay" style="text-align:center;"><span id="currentPlayerName"></span> ist dran</div>
  <div class="word-input">
    <input type="text" placeholder="Wort 1">
    <input type="text" placeholder="Wort 2">
    <input type="text" placeholder="Wort 3">
    <input type="text" placeholder="Wort 4">
    <input type="text" placeholder="Wort 5">
  </div>
  <button onclick="saveWords()">Wörter speichern</button>
</div>

<div id="handoverPhase" class="phase">
  <h2>Handy weitergeben</h2>
  <div style="text-align:center; margin:20px;"><strong><span id="handoverPlayerName"></span></strong> ist jetzt dran</div>
  <button onclick="showPlayerWord()">Bereit</button>
</div>

<div id="wordDisplayPhase" class="phase">
  <div class="word-display"><span id="displayedWord"></span></div>
  <button onclick="nextPlayer()">Weiter</button>
</div>

<!-- >>> NEU: Finger-Chooser-Phase <<< -->
<div id="chooserPhase" class="phase">
  <h2>Finger-Auswahl</h2>
  <div style="text-align:center; margin-bottom:10px; opacity:.9">
    Legt alle gleichzeitig euren Finger auf den Screen. Erst wenn <b><span id="fingerNeeded">X</span></b> Finger erkannt sind, wird zufällig <b>1 Finger</b> ausgewählt.
  </div>
  <div id="chooserSurface" aria-label="Finger-Auswahlfläche"></div>
  <div class="chooserInfo">
    Erkannt: <b><span id="fingerCount">0</span></b>/<b><span id="fingerNeeded2"></span></b> Finger
  </div>
  <div style="text-align:center">
    <button id="chooserContinue" style="display:none" onclick="enterFirstVote()">Weiter zur Abstimmung</button>
  </div>
</div>

<div id="cyclePhase" class="phase">
  <h2>Abstimmung</h2>
  <div id="cycleNumber"></div>
  <button onclick="startNextCycle()">Nächste Abstimmung</button>
  <button onclick="startVoting()">Abstimmen</button>
</div>

<div id="votingPhase" class="phase">
  <h2>Wer ist der Imposter?</h2>
  <ul class="player-list" id="playerList"></ul>
</div>

<div id="scoresPhase" class="phase">
  <h2>Schluckstand</h2>
  <div class="scores" id="scoreDisplay"></div>
  <button onclick="startNewRound()">Nächste Runde</button>
</div>
`;

// Counter unten doppelt anzeigen (ästhetisch)
document.getElementById('fingerNeeded2').textContent = document.getElementById('fingerNeeded').textContent;

/* Pointer Events für Chooser binden */
const surface = document.getElementById('chooserSurface');
surface.addEventListener('pointerdown', chooserPointerDown, { passive:false });
surface.addEventListener('pointermove', chooserPointerMove, { passive:false });
surface.addEventListener('pointerup', chooserPointerUp, { passive:false });
surface.addEventListener('pointercancel', chooserPointerUp, { passive:false });
surface.addEventListener('pointerleave', (e)=>{ /* Ignorieren, Finger bleibt drauf */ });

showPhase('modeSelectPhase');
</script>
</body>
</html>
